<?php
class SQDE_SequodeExpressor{
	public $sequode_model = null;
	public $instance_id;
	public $input_object;
	public $property_object;
	public $output_object;
	public $sequence_stack = array();
	public function __construct($sequode_model, $input_object=null, $property_object=null){
        $this->sequode_model = $sequode_model;
        $this->input_object = $sequode_model->input_object;
        $this->property_object = $sequode_model->property_object;
        $this->output_object = $sequode_model->output_object;
        if($input_object != null){
            $this->input_object = $input_object;
        }
        if($property_object != null){
            $this->property_object = $property_object;
        }
        return $this;
	}
	public function run(){
        
        $ip_stacks = array(
            'input_object' => (object) array('stack' => 'Inp_Obj', 'stack_map' => 'Inp_Obj_Map', 'runtime_map' => 'input_output_runtime_map'),
            'property_object' => (object) array('stack' => 'Prop_Obj', 'stack_map' => 'Prop_Obj_Map', 'runtime_map' => 'property_output_runtime_map')
        );
        $o_stacks = array(
            'output_object' => (object) array('stack' => 'Out_Obj', 'stack_map' => 'Out_Obj_Map')
        );
        
        $all_stacks = array_merge(
            $ip_stacks,
            $o_stacks
        );
        $sequence_stack = array();
        foreach($all_stacks as $member => $object){
            $this->stacks($object->stack,'stack',json_decode('{"Root":""}'));
        }
        foreach($this->sequode_model->sequence as $key => $id){
            $sequode_model = SQDE_SequodeChain::model($id);
            $sequence_stack[] = $sequode_model;
            foreach($all_stacks as $member => $object){
                $this->stacks($object->stack,'stack',$sequode_model->$member);
            }
        }
        
        foreach($all_stacks as $member => $object){
            $this->stacks($object->stack_map,'replaceStack',$this->sequode_model->{$member.'_map'});
        }
		// May God the Universe forgive my soul. Shalom DovBer Lawyer ben Avraham
		
		$this->stacks('Out_Obj','replaceStack',array());
        foreach($ip_stacks as $member => $object){
            $stack = $this->stacks($object->stack, 'returnStack');
            foreach($stack as $loop_key => $loop_object){
                foreach($loop_object as $loop_member => $loop_value){
                    $location_object = json_decode(json_encode($this->stacksIterator($object->stack_map,'currentStack')));
                    if($location_object->Key == 0 && $location_object->Stack == $object->stack && $loop_member != 'Root'){
                        $loop_object->$loop_member = $this->$member->{$location_object->Member};
                    }
                    if($location_object->Key > 0 && $location_object->Stack == $object->stack){
                        $loop_object->$loop_member = $location_object->Value;
                    }
                    $this->stacksIterator($object->stack_map,'nextStack');
                }
            }
        }
        
        foreach($all_stacks as $member => $object){
            $this->stacksIterator($object->stack,'nextStack');
        }
		foreach($sequence_stack as $map_key => $sequode_model){
            foreach($ip_stacks as $member => $object){
                $sequode_model->$member = $this->stacksIterator($object->stack,'currentStack');
                $this->stacksIterator($object->stack,'nextStack');
                $runtime_map = $this->sequode_model->{$object->runtime_map};
                if(isset($runtime_map[$map_key + 1]) && is_array($runtime_map[$map_key + 1])){
                    foreach($runtime_map[$map_key + 1] as $loop_member => $value){
                        $sequode_model->$member->$loop_member = $this->stacks('Out_Obj','returnKey',$value['key'])->$value['member'];
                    }
                }
                foreach($sequode_model->$member as $loop_member => $value){
                    if(is_string($value) && (strtolower($value) == 'true' || strtolower($value) == 'false')){
                        $sequode_model->$member->$loop_member = (strtolower($value) == 'true') ? true : false;
                    }
                }
            }
            
            $sequode = ($sequode_model->usage_type == 0)
                ? $sequode_model->code
                : new SQDE_SequodeExpressor($sequode_model, $sequode_model->input_object, $sequode_model->property_object);
            
            $this->stacks('Out_Obj','stack',(
                ($sequode_model->usage_type == 0)
                    ? call_user_func_array($sequode, array($sequode_model, $sequode_model->input_object, $sequode_model->property_object))
                    : $sequode->run()->output_object)
                );
		}
            $stack = $this->stacks('Out_Obj_Map', 'returnStack');
            array_shift($stack);
            foreach($stack as $key => $object){
                if($object->Key == 0 && $object->Stack == 'Out_Obj'){
                    $this->output_object->{$object->Member} = $object->Value;
                }
            }
        //$this->output_object = $this->stacks("Out_Obj","returnStack")[0];
		return $this;
	}
	private function stacks($stack,$control,$item=''){
		static $stacks;		
		if (!is_array($stacks)){
			$stacks = array();	
		}
		if (is_string($stack) && (!isset($stacks[$stack]) || $stacks[$stack] === null)) {
			$stacks[$stack] = array();
		}
		switch($control){
			case 'stack':
				$key = count($stacks[$stack]);
				$stacks[$stack][] = $item;
				return $key;
			case 'replaceStack':
				return $stacks[$stack] = $item;
			case 'replaceAllStacks':
				return $stacks = $item;
			case 'returnKey':
                if(!isset($stacks[$stack][intval($item)])){
                    return false;
                }
				return $stacks[$stack][intval($item)];
			case 'returnStack':
				return $stacks[$stack];
			case 'returnAllStacks':
				return $stacks;
			case 'clearStack':
				$stacks[$stack] = array();
				return true;
			case 'clearAllStacks':
				$stacks = array();
				return true;
			default:
				return false;
		}
    }
	private function stacksIterator($stack,$control,$item=''){
		static $keys;		
		if (!is_array($keys)) {
			$keys = array();	
		}
		if (is_string($stack) && (!isset($keys[$stack]) || $keys[$stack] === null)) {
			$keys[$stack] = 0;
		}
		switch($control){
			case 'nextStack':
				$keys[$stack]++;
				if(intval($keys[$stack]) == count($this->stacks($stack,'returnStack'))){
					$keys[$stack] = 0;
				}
			case 'currentStack':
				return self::stacks($stack,'returnKey',$keys[$stack]);
			case 'currentStackKey':
				return intval($keys[$stack]);
			case 'resetStack':
				$keys[$stack] = 0;
				return true;
			case 'resetkeys':
				$keys = array();
				return true;
			default:
				return false;
		}
	}
}