var XHRCall = function(){
	var self = this;
    self.send = function (){
        if(arguments.length != 0 && typeof arguments[0] == "object" && 'route' in arguments[0]){
            for(var i in arguments[0]){
                self[i] = arguments[0][i];
            }
        }
        var o = new XHRObject();
        o.route = self.route;
        o.protocol = self.protocol;
        o.protocol_version = self.protocol_version;
        o.domain = self.domain;
        o.server_route = self.server_route;
        o.method = self.method;
        o.content_type = self.content_type;
        o.prepare_handler = self.prepare_handler
        o.transport_handler = self.transport_handler;
        o.response_handler = self.response_handler;
        o.start_callback = self.start_callback;
        o.loading_callback = self.loading_callback;
        o.done_callback = self.done_callback;
        o.XMLHttpRequest(self.inputs);
        self.setDefaults();
    }
    self.setDefaults = function(){
        self.route = '';
        self.inputs = [];
        self.protocol = window.location.protocol;
        self.protocol_version = 'HTTP/1.1';
        self.domain = window.location.host;
        self.server_route = '/xhr'
        self.method = 'POST';
        self.content_type = 'application/x-www-form-urlencoded';
        self.prepare_handler = false;
        self.transport_handler = false;
        self.response_handler = false;
        self.start_callback = false;
        self.loading_callback = false;
        self.done_callback = false;
    }
    self.setDefaults();
    if(arguments.length != 0){
        self.send(arguments[0]);
    }
}
var XHRObject = function(){
	var self = this;    
    self.XMLHttpRequestObject = function (){
        var o;
        try {
            o = new ActiveXObject("Msxml2.XMLHTTP");
        }catch(e){
            try{
                o = new ActiveXObject("Microsoft.XMLHTTP");
            }catch(e){
                o = null;
            }
        }
        if(!o && typeof XMLHttpRequest != "undefined"){
            o = new XMLHttpRequest();
        };
        return o;
    };
    self.getCompleteRoute = function(){
        return self.protocol + '//' + self.domain + self.server_route;
    };
    self.prepareData = function(d){
        if(!self.prepare_handler){
            var i,o;
            o = 'sub=' + escape(self.route);
            for (i=0; i<d.length; i++){
                o = o + '&args[]=' + escape(d[i]);
            }
            return o;
        }else{
            return self.prepare_handler();
        }
    };
    self.transportData = function(d){
        if(!self.transport_handler){
            var r;
            r = self.XMLHttpRequestObject();
            r.open(self.method, self.getCompleteRoute(), true);
            r.setRequestHeader('Content-Type', self.content_type);
            r.onreadystatechange = function() {
                self.handleResponseState(r.readyState, r.status, r.responseText);
            }
            r.send(d);
            delete r;
        }else{
            self.transport_handler(d);
        }
    };
    self.handleResponseState = function(state, status, d){
        var r;
        switch(state){
            case 1:
                break;
            case 2:
                if(self.start_callback != false){setTimeout(self.start_callback,0)};
                return;
            case 3:
                if(self.loading_callback != false){setTimeout(self.loading_callback,0)};
                return;
            case 4:
                switch(status){
                    case 200:
                    case 301:
                    case 302:
                    case 303:
                    case 304:
                        self.handleResponseData(d);
                        break;
                    default:
                        if(d != ''){
                            try{
                                console.log(d);
                            }catch(e){
                                return;
                            }
                        }
                        break;
                }
                break;
            default:
                break;
        }
        return;
    };
    self.handleResponseData = function(d){
        if(!self.response_handler){
            if(d != ''){
                try{
                    eval(d);
                }catch(e){
                    console.log(d);
                }
            }
            if(self.done_callback != false){setTimeout(self.done_callback,0)};
        }else{
            self.response_handler(d);
        }
    };
    self.XMLHttpRequest = function(parameters) {
        self.transportData(self.prepareData(parameters));
    }
}
var BaseKit = function(){
	var self = this;
	self.doCallback = function(callback_method, callback_object){
		if (typeof callback_object === "object" && typeof callback_object[callback_method] === "function") {
			callback_object[callback_method]();
		}else if (typeof callback_method() === "function") {
			callback_method();
		}
	}
	self.getURLVar = function (name) {
		var url = String(document.location);
		var varibles = [];
		if(url.indexOf('?') != -1){
			if(url.split('?')[1].indexOf('&') != -1){
				varibles = url.split('?')[1].split('&');
			}else{
				varibles.push(url.split('?')[1]);
			}
		}
		for(i=0; i<=(varibles.length); i++){
			if(String(varibles[i]).indexOf('=') != -1 && varibles[i].split('=')[0] == name) {
				return varibles[i].split('=')[1];
			}
		}
		return null;
	}
}
var Cards = function(){
	var self = this;
    self.initialized = false;
    self.details_route = 'cards/sequode/details';
    self.icon = 'sequode';
    self.cards_dom_container = '';
    self.major_collection = '';
    self.minor_collection = '';
    self.initialize = function(){
        if(self.initialized == true){ return;}
        self.initialized = true;
    }
    self.run = function(){
        self.runCollection(registry.active_collection);
    };
    self.runCollection = function(collection_key){
        self.cards = [];
        var collection = registry.collection(collection_key);
        if(Object.keys(collection).length == 1){
            new XHRCall({route:self.details_route, inputs:[collection[Object.keys(collection)[0]].id]});
        }else{
            for(var id in collection){
                self.cards.push(self.card(collection[id]));
            }
            self.place();
        }
    };
    self.card = function(node){
        var card = $('<div>');
        card.addClass('automagic-card');
        card.addClass('pointer');
        var html = 
           [
            '<div class="automagic-card-head">',
            '<div class="card-icon '+ self.icon +'-icon-background"></div>',
            '<div class="card-title">'+ node.n +'</div>',
            '</div>',
            '<div class="automagic-card-body"></div>'
           ].join('');
           card.append(html);
        return self.attachCardEvents(card,node.id);
	};
    self.place = function(){
        var card ,i;
        $('#CardsContainer').empty();
        $('#CardsContainer').append('<div class="automagic-divider"></div>');
        for(i in self.cards){
            
            $('#CardsContainer').append(self.cards[i]);
            $('#CardsContainer').append('<div class="automagic-shim"></div>');
        }
	};
	self.attachCardEvents = function(card,id){
            card.on("click touchend", function(){
                new XHRCall({route:self.details_route, inputs:[id]});
            });
        return card;
	};
    self.initialize();
}
var CardsKit = function(){
	var self = this;
    
	self.card = function(stdObj){
        var o = {};
        o.card = $('<div>');
        o.element = o.card; 
        if(stdObj.dom_id){
            o.id = stdObj.dom_id;
            o.element.attr('id', stdObj.dom_id);
        }
        if(stdObj.z_index){
            o.z_index = stdObj.z_index;
            o.element.css("z-index", o.z_index);
        }
        if(stdObj.position){
            o.position = stdObj.position;
            o.element.css("position", o.position);
        }
        o.card.addClass('automagic-card');
        if(stdObj.css_class){
            o.card.addClass(stdObj.css_class);
        }
        if(stdObj.css_classes){
            for(var i=0; i < stdObj.css_classes.length; i++  ){
                o.card.addClass(stdObj.css_classes[i]);
            }
        }
        o.head = $('<div>'); 
        o.head.addClass('automagic-card-head');
        if(stdObj.head){
            o.head.append(stdObj.head);
        }
        o.body = $('<div>'); 
        o.body.addClass('automagic-card-body');
        if(stdObj.body){
            o.body.append(stdObj.body);
        }
        o.card.append(o.head);
        o.card.append(o.body);
        return o;
	};
	self.shim = function(){
        var o = {};
        o.shim = $('<div>');
        o.element = o.shim;
        o.shim.addClass('automagic-shim');
        return o;
	};
	self.deck = function(stdObj){
        var o = {};
        o.deck = $('<div>');
        o.element = o.deck;
        if(stdObj.dom_id){
            o.id = stdObj.dom_id;
            o.element.attr('id', stdObj.dom_id);
        }
        o.element.addClass('card-grid');
        if(stdObj.css_class){
            o.element.addClass(stdObj.css_class);
        }
        return o;
	};
    
    self.sleeve = function(stdObj){
        var o = {};
        o.sleeve = $('<div>');
        o.dom_id = stdObj.dom_id + '_CardSleeve';
        o.element = o.sleeve;
        o.sleeve.attr('id',o.dom_id);
        o.sleeve.addClass('automagic-card-sleeve');
        return o;
	};
}
var CollectionCards = function(){
	var self = this;
    self.run = function(){
        self.runCollection(self.collection);
    };
    self.runCollection = function(collection_key){
        self.cards = [];
        var collection = registry.collection(collection_key);
        for(var id in collection){
            self.cards.push(self.card(collection[id]));
        }
        self.place();
    };
    self.card = function(node){
        var card = $('<div>');
        card.addClass('automagic-card');
        card.addClass('pointer');
        var html = 
           [
            '<div class="automagic-card-head">',
            '<div class="card-icon '+ self.icon +'-icon-background"></div>',
            '<div class="card-title ">'+ node.n +'</div>',
            '</div>',
            '<div class="automagic-card-body"></div>'
           ].join('');
           card.append(html);
        return self.attachCardEvents(card,node.id);
	};
    self.place = function(){
        var card ,i;
        $('#' + self.container).empty();
        $('#' + self.container).append('<div class="automagic-divider"></div>');
        for(i in self.cards){
            $('#' + self.container).append(self.cards[i]);
            $('#' + self.container).append('<div class="automagic-shim"></div>');
        }
	};
	self.attachCardEvents = function(card,id){
            card.on("click touchend", function(){
                new XHRCall({route:self.details_route, inputs:[id]});
            });
        return card;
	};
}
var Configuration = function(){
	var self = this;
	self.sequencer_stage = {
		container: 'container',
		width: $(window).width(),
		height: $(window).height()-5
	};
    var model_width = 35;
    var segment_height = 16;
    var padding_height = 10;
    var stroke_width = 1;
	self.model = {};
	self.model.group = { draggable:true, dragDistance: 3};
	self.model.width = model_width;
	self.model.stroke_width = stroke_width;
	self.model.padding_height = padding_height;
	self.model.segment_height = segment_height;
	self.model.button_types = ['i','p','o'];
    self.model.button_positions_x = {'i':3.25,'p':(model_width/2),'o':model_width-3.25};
	self.model.button_type_height_adjustment = {'i':0,'p':(segment_height/2),'o':0};
    self.model.button_type_colors = {'i':'yellow','p':'#306EFF','o':'#00FF00'};
    
	self.model.halo = {
		x:(model_width / 2),
		y:0, 
		width: model_width, 
		height: 0,
		radius: (model_width / 4), 
		fill: 'white',
		stroke: 'black',
		strokeWidth: 1
	};
	self.model.button = {
		x: 0,
		y: 0,
		radius: 6,
		fill: 'gray',
		stroke: 'black',
		strokeWidth: 1
	};
	self.model.body = {
		x:0,
		y:0,
		width: model_width,
		height: 0,
		stroke: 'black',
		cornerRadius: 10,
        fill:'white',
		strokeWidth: 1
	};
	self.tip = {};
	self.tip.text = {
		text: '',
		fontFamily: 'Calibri',
		fontSize: 14,
		padding: 4,
		fill: 'black'
	};
    
	self.tip.label = {
		x: 0,
		y: 0,
		opacity: 1.00
	};
	self.tip.tag = {
		fill: 'white',
		pointerDirection: 'down',
		pointerWidth: 5,
		pointerHeight: 10,
		lineJoin: 'round',
		stroke: 'black',
		strokeWidth: 1
	};
	self.sequencer = {};
	self.sequencer.grid_area_auger = {
		x:0,
		y:0,
		radius: 10, 
		fill: 'white',
		stroke: 'black',
		strokeWidth: 1
	};
	self.sequencer.grid_area_auger_collider = {
		x:-15,
		y:-15,
		width: 30, 
		height: 30,
        fill: 'black',
		opacity: 0.0
	};
	self.sequencer.grid_area_number = {
        x:-.5,
        y:-.5,
		fontSize:11,
		fill:'#333333',
        fontStyle:'bold'
	};
    self.sequencer.distance_y = 15;
	self.sequencer.grid_flow_line = {
		x:0,
		y:0,
		radius: (model_width * .33), 
		fill: 'white',
		stroke: 'black',
		strokeWidth: 1
	};
	self.sequencer.grid_cell_width = 65;
	self.sequencer.grid_padding = 30;
    self.model_end_head = {};
    self.model_end_head.body = {
		x:0,
		y:0,
		width: model_width / 2,
		height: 0,
		fill: 'white',
		stroke: 'darkgray',
		cornerRadius: 5,
		strokeWidth: 1
	};
	self.model_end_base = {};
    self.model_end_base.body = {
		x:self.model.width / 2,
		y:0,
		width: self.model.width / 2,
		height: 0,
		fill: 'white',
		stroke: 'darkgray',
		cornerRadius: 5,
		strokeWidth: 1
	};
    self.copy = function(obj){
        var newObj = {};
        for(i in obj){
            newObj[i] = obj[i];
        }
        return newObj;
    }
    self.get = function(group,obj){
        var newObj = {};
        for(i in self[group][obj]){
            newObj[i] = self[group][obj][i];
        }
        return newObj;
    }
}
var EventsKit = function(){
	var self = this;
    self.attachDraggableCursorEvents = function(shape){
        shape.on('touch mousedown', function() {
            document.body.style.cursor = '-webkit-grabbing';
		});
        shape.on('touchstart mouseup mouseover', function() {
            document.body.style.cursor = '-webkit-grab';
		});
        shape.on('touchend mouseout', function() {
            document.body.style.cursor = 'default';
		});
        return shape;
    };
    self.attachMoveableCursorEvents = function(shape){
        shape.on('touch mousedown mouseover', function() {
            document.body.style.cursor = 'move';
		});
        shape.on('touchstart mouseup', function() {
            document.body.style.cursor = 'move';
		});
        shape.on('touchend mouseout', function() {
            document.body.style.cursor = 'default';
		});
        return shape;
    };
}

var Model = function(){
	var self = this;
	self.default_events = true;
    self.height = 35;
	self.buttons = {'i':[],'p':[],'o':[]};
	self.run = function(){
        self.group = shapesKit.group(config.model.group);
        var height_multiplier = 1;
        var most_buttons = 'p';
        var padding_multiplier = 3.5;
		for(var type in self.buttons){
			if ( height_multiplier < self.node[type].length ){
                most_buttons = type;
				height_multiplier = self.node[type].length;
			}
		}
        if((most_buttons != 'p' && self.node['p'].length != self.node[most_buttons].length) && !(self.node['i'].length == self.node['p'].length && self.node['p'].length == self.node['o'].length)){
            padding_multiplier = 2;
        }
        self.height = ((height_multiplier - 1)*config.model.segment_height)+(config.model.padding_height*padding_multiplier);
		self.buildModel();
	};
	self.buildModel = function(){
        setTimeout(self.makeCollider,0);
        setTimeout(self.makeBody,0);
        setTimeout(self.makeHalo,0);
        setTimeout(self.makeButtons,0);
		switch(self.valignment){
			case 'bottom':
				self.group.setY(self.y - self.height);
				break;
			case 'top':
			default:
				self.group.setY(self.y);
		}
		self.group.setX(self.x);
		self.layer.add(self.group);
	};
	self.makeHalo = function(){
		var o = {};
		o.inpObj = config.get('model','halo');
		o.inpObj.height = self.height;
		o.shape = shapesKit.circle(o.inpObj);
        if( self.default_events == true ){
            var t = false;
            o.shape.on('mouseout', function(){
                if(t != false){
                    t.shape.remove();
                    t.shape.destroy();
                    t = false;
                    self.layer.batchDraw();
                }
            });
            o.shape.on('mouseover', function() {
                if(t == false){
                    document.body.style.cursor = '-webkit-grab';
                    t = shapesKit.tip({x:o.inpObj.x,y:o.inpObj.y - o.inpObj.radius,text:decodeURIComponent(self.node.n)});
                    self.group.add(t.shape);
                    self.group.moveToTop();
                    t.shape.moveToTop();
                    self.layer.batchDraw();
                }
            });
            o.shape.on('touchend', function(){
                if(t != false){
                    t.shape.remove();
                    t.shape.destroy();
                    t = false;
                    self.layer.batchDraw();
                }else{
                    document.body.style.cursor = '-webkit-grab';
                    t = shapesKit.tip({x:o.inpObj.x,y:o.inpObj.y - o.inpObj.radius,text:decodeURIComponent(self.node.n)});
                    self.group.add(t.shape);
                    self.group.moveToTop();
                    t.shape.moveToTop();
                    self.layer.batchDraw();
                }
            });
        }
		self.group.add(o.shape);
        self.halo = o.shape;
	};
	self.makeBody = function(){
		var o = {};
		o.inpObj = config.get('model','body');
		o.inpObj.height = self.height;
		o.shape = shapesKit.box(o.inpObj);
        if( self.default_events == true ){
            o.shape.on('mouseover touch', function() {
                self.group.moveToTop();
                self.group.draggable(true);
                self.layer.batchDraw();
            });
            o.shape.on('mouseout touchend', function() {
                self.group.moveToTop();
                self.layer.batchDraw();
            });
        }
		self.group.add(o.shape);
        self.body = o.shape;
	};
	self.makeButtons = function(){
		for(var ipo in self.buttons){
			for (var i=0;i<self.node[ipo].length;i++){
                self.makeButton(ipo,i);
			}
		}
	};
	self.makeButton = function(m,i){
		var o = {};
		o.inpObj = config.get('model','button');
		o.inpObj.fill = config.model.button_type_colors[m];
		o.inpObj.x = config.model.button_positions_x[m];
		o.inpObj.y = self.height - ( config.model.padding_height + ( i * config.model.segment_height) + config.model.button_type_height_adjustment[m] );
        o.shape = shapesKit.circle(o.inpObj);
        if( self.default_events == true ){
            var t = false;
            o.shape.on('mouseout', function(){
                if(t != false){
                    document.body.style.cursor = 'default';
                    if(self.original){
                        self.parent.wiring_layer.show();
                    }
                    self.group.setDraggable(false);
                    t.shape.remove();
                    t.shape.destroy();
                    t = false;
                    self.layer.batchDraw();
                }
            });
            o.shape.on('mouseover', function() {
                if(t == false){
                    document.body.style.cursor = 'pointer';
                    if(self.original){
                        self.parent.wiring_layer.hide();
                    }
                    t = shapesKit.tip({x:o.inpObj.x,y:o.inpObj.y - o.inpObj.radius,text:decodeURIComponent(self.node[m][i].n)});
                    self.group.add(t.shape);
                    self.group.setDraggable(false);
                    self.group.moveToTop();
                    t.shape.moveToTop();
                    self.layer.batchDraw();
                }
            });
            o.shape.on('touchend', function(){
                if(t != false){
                    document.body.style.cursor = 'default';
                    if(self.original){
                        self.parent.wiring_layer.show();
                    }
                    self.group.setDraggable(false);
                    t.shape.remove();
                    t.shape.destroy();
                    t = false;
                    self.layer.batchDraw();
                }else{
                    document.body.style.cursor = 'pointer';
                    if(self.original){
                        self.parent.wiring_layer.hide();
                    }
                    t = shapesKit.tip({x:o.inpObj.x,y:o.inpObj.y - o.inpObj.radius,text:decodeURIComponent(self.node[m][i].n)});
                    self.group.add(t.shape);
                    self.group.setDraggable(false);
                    self.group.moveToTop();
                    t.shape.moveToTop();
                    self.layer.batchDraw();
                }
            });
        }
		self.buttons[m][i] = o.shape;
        if(m != 'p'){
            self.buttons[m][i].setScale({x:0.71,y:1.05});
        }
		self.group.add(self.buttons[m][i]);
		for(var ipo in self.buttons){
            if(self.buttons[ipo].length != self.node[ipo].length){ return; }
        }
        self.parent.modelComplete(self);
        return;
	};
	self.makeCollider = function(){
		var inpObj = {
            x: -((config.model.width * 2)/8),
            y: 0,
            width: config.model.width * 1.5,
            height: self.height,
            stroke: '#00FF00',
            strokeWidth: 1.5,
            cornerRadius: 10
		};
		self.placement_collider = shapesKit.box(inpObj);
		self.placement_collider.hide();
		self.group.add(self.placement_collider);
	};
};
var ModelEnds = function(){
	var self = this;
	self.default_events = true;
	self.types = ['head','base'];
	self.type = 'head';
	self.buttons = {'i':[],'p':[],'o':[]};
	self.run = function(){
		self.group = shapesKit.group();
        var height_multiplier = 1;
        var most_buttons = 'p';
        var padding_multiplier = 3.5;
        for(var m in self.buttons){
            if((self.type == 'head' && m == 'o') || (self.type == 'base' && (m == 'i' || m == 'p'))){
                continue;
            }
			if ( height_multiplier < self.node[m].length ){
                most_buttons = m;
				height_multiplier = self.node[m].length;
			}
		}
        if((most_buttons != 'p' && self.node['p'].length != self.node[most_buttons].length) && !(self.node['i'].length == self.node['p'].length && self.node['p'].length == self.node['o'].length)){
            padding_multiplier = 2;
        }
        self.height = ((height_multiplier - 1)*config.model.segment_height)+(config.model.padding_height*padding_multiplier);
		self.buildModel();
	};
	self.buildModel = function(){
        self.makeBody();
        self.makeButtons();
		switch(self.valignment){
			case 'bottom':
				self.group.setY(self.y - self.height);
				break;
			case 'top':
			default:
				self.group.setY(self.y);
		}
		self.group.setX(self.x);
		self.layer.add(self.group);
	};
	self.makeBody = function(){
		var inpObj;
        inpObj = config.get('model_end_'+self.type,'body');
		inpObj.height = self.height;
        self.body = shapesKit.box(inpObj);
        self.group.add(self.body);
	};
	self.makeButtons = function(){
		for(var ipo in self.buttons){
			for (var i=0;i<self.node[ipo].length;i++){
                self.makeButton(ipo,i);
			}
		}
	};
	self.makeButton = function(m,i){
		if(self.type == 'head' && m == 'o'){
			return;
		}
		if(self.type == 'base' && (m == 'i' || m == 'p')){
			return;
		}
		var o = {};
		o.inpObj = config.get('model','button');
		o.inpObj.fill = config.model.button_type_colors[m];
		o.inpObj.x = config.model.button_positions_x[m];
		o.inpObj.y = self.height - ( config.model.padding_height + ( i * config.model.segment_height ) + config.model.button_type_height_adjustment[m] );
		o.shape = shapesKit.circle(o.inpObj);
        o.shape = shapesKit.circle(o.inpObj);
        if( self.default_events == true ){
            var t = false;
            o.shape.on('mouseout', function(){
                if(t != false){
                    document.body.style.cursor = 'default';
                    self.group.setDraggable(false);
                    t.shape.remove();
                    t.shape.destroy();
                    t = false;
                    self.layer.batchDraw();
                }
            });
            o.shape.on('mouseover', function() {
                if(t == false){
                    document.body.style.cursor = 'pointer';
                    t = shapesKit.tip({x:o.inpObj.x,y:o.inpObj.y - o.inpObj.radius,text:decodeURIComponent(self.node[m][i].n)});
                    self.group.add(t.shape);
                    self.group.setDraggable(false);
                    self.group.moveToTop();
                    t.shape.moveToTop();
                    self.layer.batchDraw();
                }
            });
            o.shape.on('touchend', function(){
                if(t != false){
                    document.body.style.cursor = 'default';
                    self.group.setDraggable(false);
                    t.shape.remove();
                    t.shape.destroy();
                    t = false;
                    self.layer.batchDraw();
                }else{
                    document.body.style.cursor = 'pointer';
                    t = shapesKit.tip({x:o.inpObj.x,y:o.inpObj.y - o.inpObj.radius,text:decodeURIComponent(self.node[m][i].n)});
                    self.group.add(t.shape);
                    self.group.setDraggable(false);
                    self.group.moveToTop();
                    t.shape.moveToTop();
                    self.layer.batchDraw();
                }
            });
        }
		self.buttons[m][i] = o.shape;
		self.group.add(self.buttons[m][i]);
	};
};
var Sequencer = function(){
	var self = this;
    var stage;
	self.default_events = true;
    self.palette = new SequencerPalette;
    self.palette.parent = self;
    self.initialized = false;
    self.first_run_complete = false;
	self.active = false;
	self.dict = ['models','sequence','flow_lines_layer','grid_areas_layer','sequence_layer','wiring_layer','ends_layer','view_positioner_layer','id','dragging','drag_id','y','tweens_playing','grids','grid','grid_mode','grid_x','grid_order','align_lock'];
	self.models = [];
	self.IOPmodels = { 'head':false, 'base':true };
    self.grid_auger_types = ['prepend','split','append'];
    self.connections = {'i':[],'p':[],'o':[]};
    self.connecters = {'i':[],'p':[],'o':[]};
	self.gridarea_height = 200;
    self.view_layers_offset = {x:0,y:0};
    self.view_layers_starting_offset = {x:0,y:0};
    self.all_layers = ['flow_lines_layer','grid_areas_layer','sequence_layer','wiring_layer','ends_layer','view_positioner_layer'];
    self.view_layers = ['flow_lines_layer','grid_areas_layer','sequence_layer','wiring_layer','ends_layer'];
    self.initialize = function(){
        if(self.initialized == true){
            return;
        }
        self.initialized = true;
    };
    self.tearDown = function(id){
		if(self.active == false){ return;}
        if(id != self.id){
            self.view_layers_offset = {x:0,y:0};
            self.first_run_complete == false;
        }
        self.initialized = false;
		self.view_positioner_layer.remove();
		self.grid_areas_layer.remove();
		self.flow_lines_layer.remove();
		self.sequence_layer.remove();
		self.ends_layer.remove();
		self.wiring_layer.remove();
		self.view_positioner_layer.destroy();
		self.grid_areas_layer.destroy();
		self.flow_lines_layer.destroy();
		self.sequence_layer.destroy();
		self.ends_layer.destroy();
		self.wiring_layer.destroy();
		var i;
		for( i in self.dict){
			self[self.dict[i]] = undefined;
		}
	};
    self.makeChartViewable = function(){
        self.center_stage = {x:Math.floor(stage.getWidth()/2), y:Math.floor(stage.getHeight()/2)};
        if(self.view_layers_offset.x != 0 || self.view_layers_offset.y != 0 ){return;}
        self.view_layers_offset = {x:Math.floor((stage.getWidth()/2)- (self.gridAreaWidth(self.node.grid_areas[0].count)/2)),y:Math.floor(stage.getHeight()/2)};
            
    };
    self.modelComplete = function(model){
        self.models[model.sequence_order] = self.modelEventListeners(model);;
        self.models_done++;
        if(self.models_done == self.sequence.length){
            self.modelsComplete();
        }
    };
	self.modelsComplete = function(){
        self.sequenceIPOConnectionModels();
		self.makeWiringStacks();
		self.makeWiring();
        self.wiring_layer.moveToTop();
        setTimeout(self.makeGridAreaTchotchkes,0);
    };
    self.run = function(){
		id = parseInt((arguments.length != 0) ? arguments[0] : self.id);
        self.tearDown(id);
        
        stage = self.stage;
        
        if( self.default_events == true ){
            registry.fetch({collection:'palette'});
        }
        self.grid_areas = [];
        self.focused_grid_area_id = false;
        
        registry.active_sequence = id;
        self.grid_flow_lines_done = 0;
        
        self.connection_receiver = false;
        self.connection_transmitter = false;
        self.focused_grid_area_id = false;
        self.grid_area_augmenter = false;
        self.grid_auger_split_position = false;
		self.view_positioner_layer = new Kinetic.Layer();
		stage.add(self.view_positioner_layer);
		self.flow_lines_layer = new Kinetic.Layer();
		stage.add(self.flow_lines_layer);
		self.grid_areas_layer = new Kinetic.Layer();
		stage.add(self.grid_areas_layer);
		self.ends_layer = new Kinetic.Layer();
		stage.add(self.ends_layer);
		self.sequence_layer = new Kinetic.Layer();
		stage.add(self.sequence_layer);
		self.wiring_layer = new Kinetic.Layer();
		stage.add(self.wiring_layer);
		self.node = registry.node('sequodes', id);
        if(self.node.s.length > 0 ){
            setTimeout(self.makeViewPositioner,0);
            self.makeChartViewable();
        }
		self.sequence = self.node.s;
		self.id = id;
		self.dragging = false;
		self.drag_id = false;
		self.align_lock = false;
		self.IOPmodels = { 'head':false, 'base':true };
		self.connections = {'i':[],'p':[],'o':[]};
		self.connecters = {'i':[],'p':[],'o':[]};
		self.tweens_playing = [];
		self.models = [];
		self.grid_states = { 'add': '', 'sequence': '', 'remove': '' } ;
        self.grid = [];
        self.grid_order = [];
        if(self.sequence.length != 0){
            self.grids = { 'add': [], 'sequence': [], 'remove': [] };
            self.makeGridAreas();
            self.setGridMode('sequence');
            self.makeSequenceModels();
        }
		self.active = true;
	};
	self.gridPositionerComplete = function(model){
        self.model_positioners_done++;
        if(self.model_positioners_done != self.grid_areas.length){return;}
        if(self.grid_areas.length == 1){
            self.complete();
        }else{
            self.makeGridFlowLines();
        }
    }
    self.gridFlowLineComplete = function(model){
        self.grid_flow_lines_done++;
        if(self.grid_flow_lines_done != self.grid_areas.length -1){return;}
        self.complete();
    }
    self.makeViewPositioner = function(){
        var o = {};
        o.width = stage.getWidth();
        o.height = stage.getHeight();
		o.x = 0;
        o.y = 0;
        o.group = new Kinetic.Group({x:o.x, y:o.y, draggable:true, dragDistance:2});
        o.box = new Kinetic.Rect({
            x: 0,
            y: 0,
            width: o.width,
            height: o.height
		});
        o.group.add(o.box);
        o = self.viewerPositionerEventListeners(o);
        self.view_positioner_layer.add(o.group);
        self.view_positioner_layer.moveToBottom();
	};
	self.makeSequenceModels = function(){
        self.models_done = 0;
		var model;
		var node;
		var grid_area;
        var sequence_order = 0;
		for( var area_id in self.grid_areas ){
            grid_area = self.grid_areas[area_id];
            for(var i=0; i<grid_area.models.length; i++){
                node = registry.node('sequodes',self.sequence[sequence_order]);
                model = new Model();
                model.parent = self;
                model.original = true;
                model.sequence_id = grid_area.models[i];
                model.sequence_order = sequence_order;
                model.order = i;
                model.grid_area = area_id;
                model.node = node;
                model.id = node.id;
                model.stage = stage;
                model.layer = self.sequence_layer;
                model.x = grid_area.x + grid_area.sequence[i];
                model.y = grid_area.y;
                model.valignment = 'bottom';
                model.run();
                self.models[grid_area.models[i]] = model;
                sequence_order++;
            };
        }
	};
	self.sequenceIPOConnectionModels = function(){
		var model;
		var node;
		for(type in self.IOPmodels){
			node = registry.node('sequodes', self.id);
			model = new ModelEnds();
			model.parent = self;
			model.node = node;
			model.id = self.id;
			model.stage = stage;
			model.layer = self.ends_layer;
            if(self.sequence.length != 0){
                if( type == 'head' ){
                    model.x = self.grid_areas[0].box.getAbsolutePosition().x - 8;
                    model.y = self.grid_areas[0].box.getAbsolutePosition().y + (self.grid_areas[0].box.getHeight()*.85);
                }else if( type == 'base' ){
                    model.x = self.grid_areas[self.grid_areas.length-1].box.getAbsolutePosition().x - 25 + self.grid_areas[self.grid_areas.length-1].box.getWidth();
                    model.y = self.grid_areas[self.grid_areas.length-1].box.getAbsolutePosition().y + (self.grid_areas[self.grid_areas.length-1].box.getHeight()*.85);
                }
            }else{
                model.y = self.grid_areas[0].y + (self.grid_areas[0].box.getHeight()*.5);
                if( type == 'head' ){
                    model.x = self.grid_areas[0].x;
                }else if( type == 'base' ){
                    model.x = self.grid_areas[0].x + self.grid_areas[0].box.getWidth();
                }
            }
			model.valignment = 'bottom';
			model.type = type;
			model.run();
			self.IOPmodels[type] = self.modelEndsEventListeners(model);
		}
	};
    self.makeGridAreas = function(){
        var i,j,k = 0;
        self.focused_grid_area_id = false;
        self.grid_areas = [];
        for(i=0;i<self.node.grid_areas.length;i++){
            self.grid_areas[i] = {'id':i,'models':[],'grid_order':[]};
            for(j=0;j<self.node.grid_areas[i].count;j++){
                self.grid_areas[i].models.push(k);
                self.grid_areas[i].grid_order.push(j);
                k++;
            }
        };
        for(var i in self.grid_areas){
            self.grid_areas[i] = self.makeGridArea(self.grid_areas[i]);
            self.grid_areas[i] = self.makeGridAreaStates(self.grid_areas[i]);
            self.grid_areas[i] = self.gridareaEventListeners(self.grid_areas[i]);
            self.grid_areas_layer.add(self.grid_areas[i].group);
        }
	};
    self.makeGridArea = function(grid_area){
        var layer, width, height, x, y, group_x, group_y;
        width = self.gridAreaWidth(grid_area.models.length);
        height = self.gridarea_height;
        x = self.node.grid_areas[grid_area.id].x;
		y = self.node.grid_areas[grid_area.id].y;
        group_x = x - config.sequencer.grid_cell_width*.5 - 15;
        group_y = y - height + config.sequencer.grid_cell_width*.5;
        grid_area.x = x;
        grid_area.y = y;
        grid_area.width = width;
        grid_area.height = height;
        grid_area.group = new Kinetic.Group({x:group_x, y:group_y, draggable:true,dragDistance:2});
        layer = {};
        layer.width = width + (config.sequencer.grid_cell_width*5);
        layer.height = height + (config.sequencer.grid_cell_width) - (config.sequencer.grid_cell_width*.5);
		layer.x = group_x - config.sequencer.grid_cell_width - (config.sequencer.grid_cell_width*1.5);
        layer.y = group_y;
        layer.box = new Kinetic.Rect({
            x: layer.x,
            y: layer.y,
            width: layer.width,
            height: layer.height,
            stroke: '#00FF00',
            strokeWidth: 1.5,
            cornerRadius: 10
		});
        self.grid_areas_layer.add(layer.box);
        grid_area.placement_collider = layer.box
        
        layer = {};
        layer.width = width;
        layer.height = height;
		layer.x = group_x;
        layer.y = group_y;
        
        layer.box = new Kinetic.Rect({
            x: group_x,
            y: group_y,
            fill: 'white',
            width: width,
            height: height,
            stroke: '#00FF00',
            strokeWidth: 1.5,
            cornerRadius: 10
		});
        self.grid_areas_layer.add(layer.box);
        grid_area.placement_preview = layer.box;
        
        layer = {};
        layer.width = width;
        layer.height = height;
		layer.x = 0;
        layer.y = 0;
        layer.box = new Kinetic.Rect({
            x: layer.x,
            y: layer.y,
            fill: 'white',
            width: layer.width,
            height: layer.height,
            stroke: 'darkgray',
            strokeWidth: .5,
            cornerRadius: 5
		});
        grid_area.box = layer.box;
        
        grid_area.group.add(layer.box);
        
        grid_area.placement_collider.hide();
        grid_area.placement_preview.hide();
        
        return grid_area;
        
	};
    self.makeGridAreaStates = function(grid_area){
		var grid = [];
		var i;
		var state;
        for( i=0; i<grid_area.grid_order.length; i++ ){
            grid[i]=(i*config.sequencer.grid_cell_width);
        }
        grid[grid_area.grid_order.length]=(grid_area.grid_order.length*config.sequencer.grid_cell_width);
        for( state in self.grid_states ){
            if(state != 'add'){
               grid.pop();
            }
            grid_area[state] = new Array().concat(grid);
        }
        return grid_area;
	};
    self.makeGridAreaTchotchkes = function(){
        self.model_positioners_done = 0;
        for(var i=0; i < self.grid_areas.length;i++){
            setTimeout(self.makeGridAreaTchotchke, 0, i);
        }
	};
	self.makeGridAreaTchotchke = function(i){
        var inpObj;
        var grid_area = self.grid_areas[i]; 
        var grid_numbers_padding = 3;
        var top = -(grid_numbers_padding);
        var middle = grid_area.height*.5;
        var bottom = grid_area.height - (grid_numbers_padding+3);
        grid_area.next_number = false;
        if(self.grid_areas.length > 1){
            grid_area.current_number = {};
            grid_area.current_number.y = top;
            if( i > 0 && self.grid_areas.length > 1){
                if(self.grid_areas[i-1].y == grid_area.y){
                    grid_area.current_number.y = middle;
                }else if(self.grid_areas[i-1].y > grid_area.y){
                    grid_area.current_number.y = bottom;
                }
            }
            grid_area.current_number.x = 0 - (grid_numbers_padding);
            grid_area.current_number.grid_area_id = i;
            grid_area.current_number.number = i + 1;
            inpObj = config.get('sequencer','grid_area_number');
            inpObj.text = grid_area.current_number.number;
            grid_area.current_number.circle = shapesKit.circleButton(inpObj).group;
            grid_area.current_number.group = new Kinetic.Group({x:grid_area.current_number.x,y:grid_area.current_number.y});
            grid_area.current_number.group.add(grid_area.current_number.circle);
            grid_area.group.add(grid_area.current_number.group);
        }
        if(self.grid_areas.length > 1 && i != self.grid_areas.length - 1){
            grid_area.next_number = {};
            grid_area.next_number.y = top;
            if(self.grid_areas[i+1].y == grid_area.y){
                grid_area.next_number.y = middle;
            }else if(self.grid_areas[i+1].y > grid_area.y){
                grid_area.next_number.y = bottom;
            }
            grid_area.next_number.x = grid_area.box.getWidth() - grid_numbers_padding + 1;
            grid_area.next_number.grid_area_id = i;
            grid_area.next_number.number = i + 2;
            inpObj = config.get('sequencer','grid_area_number');
            inpObj.text = grid_area.next_number.number;
            grid_area.next_number.circle = shapesKit.circleButton(inpObj).group;
            grid_area.next_number.group = new Kinetic.Group({x:grid_area.next_number.x,y:grid_area.next_number.y});
            grid_area.next_number.group.add(grid_area.next_number.circle);
            grid_area.group.add(grid_area.next_number.group);
        }
        grid_area.prepend_auger = {};
        grid_area.prepend_auger.x = 0;
        grid_area.prepend_auger.y = grid_area.box.getHeight()*.5;
        grid_area.prepend_auger.grid_area_id = i;
        grid_area.prepend_auger.number = i + 1;
        grid_area.prepend_auger.group = new Kinetic.Group({x:grid_area.prepend_auger.x,y:grid_area.prepend_auger.y});
        inpObj = config.get('sequencer','grid_area_auger_collider');
        grid_area.prepend_auger.collider = shapesKit.box(inpObj);
        grid_area.prepend_auger.group.add(grid_area.prepend_auger.collider);
        inpObj = config.get('sequencer','grid_area_auger');
        grid_area.prepend_auger.circle = shapesKit.circle(inpObj);
        grid_area.prepend_auger.group.add(grid_area.prepend_auger.circle);
        inpObj = config.get('sequencer','grid_area_number');
        inpObj.text = '+';
        grid_area.prepend_auger.symbol = shapesKit.text(inpObj);
        grid_area.prepend_auger.symbol.setX(-(grid_area.prepend_auger.symbol.getWidth()*.5));
        grid_area.prepend_auger.symbol.setY(-(grid_area.prepend_auger.symbol.getHeight()*.5));
        grid_area.prepend_auger.group.add(grid_area.prepend_auger.symbol);
        grid_area.prepend_auger.group.hide();
        grid_area.group.add(grid_area.prepend_auger.group);
        grid_area.append_auger = {};
        grid_area.append_auger.x = grid_area.box.getWidth();
        grid_area.append_auger.y = grid_area.box.getHeight()*.5;
        grid_area.append_auger.grid_area_id = i;
        grid_area.append_auger.number = '+';
        if(self.node.grid_areas.length-1 !== i){
            grid_area.append_auger.number = i + 2;
        }
        grid_area.append_auger.group = new Kinetic.Group({x:grid_area.append_auger.x,y:grid_area.append_auger.y});
        inpObj = config.get('sequencer','grid_area_auger_collider');
        grid_area.append_auger.collider = shapesKit.box(inpObj);
        grid_area.append_auger.group.add(grid_area.append_auger.collider);
        inpObj = config.get('sequencer','grid_area_auger');
        grid_area.append_auger.circle = shapesKit.circle(inpObj);
        grid_area.append_auger.group.add(grid_area.append_auger.circle);
        inpObj = config.get('sequencer','grid_area_number');
        inpObj.text = '+';
        grid_area.append_auger.symbol = shapesKit.text(inpObj);
        grid_area.append_auger.group.add(grid_area.append_auger.symbol);
        grid_area.append_auger.symbol.setX(-(grid_area.append_auger.symbol.getWidth()*.5));
        grid_area.append_auger.symbol.setY(-(grid_area.append_auger.symbol.getHeight()*.5));
        grid_area.append_auger.group.hide(); 
        grid_area.group.add(grid_area.append_auger.group);
        grid_area.split_auger = {};
        grid_area.split_auger.x = 0;
        grid_area.split_auger.y = grid_area.box.getHeight();
        grid_area.split_auger.grid_area_id = i;
        grid_area.split_auger.number = '+';
        grid_area.split_auger.group = new Kinetic.Group({x:grid_area.split_auger.x,y:grid_area.split_auger.y});
        inpObj = config.get('sequencer','grid_area_auger_collider');
        grid_area.split_auger.collider = shapesKit.box(inpObj);
        grid_area.split_auger.group.add(grid_area.split_auger.collider);
        inpObj = config.get('sequencer','grid_area_auger');
        grid_area.split_auger.circle = shapesKit.circle(inpObj);
        grid_area.split_auger.group.add(grid_area.split_auger.circle);
        inpObj = config.get('sequencer','grid_area_number');
        inpObj.text = grid_area.split_auger.number;
        grid_area.split_auger.symbol = shapesKit.text(inpObj);
        grid_area.split_auger.group.add(grid_area.split_auger.symbol);
        grid_area.split_auger.symbol.setX(-(grid_area.split_auger.symbol.getWidth()*.5));
        grid_area.split_auger.symbol.setY(-(grid_area.split_auger.symbol.getHeight()*.5));
        grid_area.split_auger.group.hide();       
        grid_area.group.add(grid_area.split_auger.group);
        self.grid_areas[i] = grid_area;
        self.gridPositionerComplete();
	};
    self.makeGridFlowLines = function(){
        self.grid_flow_lines_done = 0;
        for(var i=0; i < self.grid_areas.length;i++){
            if(i !== 0){
                setTimeout(self.makeGridFlowLine, 0, i);
            }
        }
	};
    self.makeGridFlowLine = function(i,notifyComplete){
        var grid_area_to = self.grid_areas[i];
        var grid_area_from = self.grid_areas[i-1];
        var from_x, from_y, to_x, to_y;
        from_x = grid_area_from.next_number.circle.getX()+grid_area_from.next_number.group.getX()+grid_area_from.group.getX()+2.5;
        from_y = grid_area_from.next_number.circle.getY()+grid_area_from.next_number.group.getY()+grid_area_from.group.getY()+6.5;
        to_x = grid_area_to.current_number.circle.getX()+grid_area_to.current_number.group.getX()+grid_area_to.group.getX()+3;
        to_y = grid_area_to.current_number.circle.getY()+grid_area_to.current_number.group.getY()+grid_area_to.group.getY()+6.5;

        grid_area_to.line = new Kinetic.Line({
            points: [from_x, from_y ,to_x , to_y],
            stroke: 'darkgray',
            strokeWidth: config.model.stroke_width
        });
        self.flow_lines_layer.add(grid_area_to.line);
        
        grid_area_to.line.moveToBottom();
        self.grid_areas[i] = grid_area_to;
        if(notifyComplete != false){
            self.gridFlowLineComplete();
        }else{
            self.complete();
        }
	};
	self.makeWiringStacks = function(){
		var connecter, connection;
		var model, node;
		var end_stack, end_key;
		var shape;
		var stack_keys = {'i':'i','p':'p','o':'o'};
		self.connections = {'i':[],'p':[],'o':[]};
		self.connecters = {'i':[],'p':[],'o':[]};
		model = self.IOPmodels['head'];
		for(var i=0;i<self.node['i'].length;i++){
			connecter = {};
			connecter.type = 'i';
			connecter.shape = model.buttons['i'][i];
			connecter.x = connecter.shape.getAbsolutePosition().x;
			connecter.y = connecter.shape.getAbsolutePosition().y;
			self.connecters['i'].push(connecter);
		}
		for(var i=0;i<self.node['p'].length;i++){
			connecter = {};
			connecter.type = 'p';
			connecter.shape = model.buttons['p'][i];
			connecter.x = connecter.shape.getAbsolutePosition().x;
			connecter.y = connecter.shape.getAbsolutePosition().y;
			self.connecters['p'].push(connecter);
		}
		for(var i=0;i<self.sequence.length;i++){
			model = self.models[i];
			node = self.node.m[i];
			for(var stack in self.connecters){
				for(var j=0;j<node[stack].length;j++){
					connecter = {};
					connecter.type = stack;
					connecter.shape = model.buttons[stack][j];
					connecter.x = connecter.shape.getAbsolutePosition().x;
					connecter.y = connecter.shape.getAbsolutePosition().y;
                    
					if(node[stack][j].srcKey != -1 && stack !='o'){
						connection = {};
						connection.start = connecter;
						end_stack = stack_keys[node[stack][j].stack];
						if(end_stack == 'i' || end_stack == 'p'){
							end_key = node[stack][j].srcKey;
						}else if(end_stack == 'o'){
							end_key = node[stack][j].srcKey;
						}
						connection.end = self.connecters[end_stack][end_key];
						self.connections[stack].push(connection);
					}
					self.connecters[stack].push(connecter);
					
				}
			}
		}
		model = self.IOPmodels['base'];
		for(var i=0;i<model.buttons['o'].length;i++){
			connecter = {};
			connecter.type = 'o';
			connecter.shape = model.buttons['o'][i];
			connecter.x = connecter.shape.getAbsolutePosition().x;
			connecter.y = connecter.shape.getAbsolutePosition().y;
			self.connecters['o'].push(connecter);
			
            node = self.node['o'][i];
			connection = {};
			connection.start = connecter;
			end_key = node.srcKey;
			connection.end = self.connecters['o'][end_key];
			self.connections['o'].push(connection);
		}
	};
	self.makeWiring = function(){
		self.wiring_group = shapesKit.group(config.model.group);
		var wire, wire1, wire2, connections, wire_group;
		var start, end, padding, start_y_padding, end_y_padding, start_x_padding, end_x_padding;
		var start_x, start_y, end_x, end_y;
        var model_button = config.get('model','button');
        var start_adjuster, end_adjuster;
        padding = (model_button.radius / 2) + model_button.strokeWidth;
        var type_stroke = {'i':'yellow','p':'#306EFF','o':'#00FF00'};
		for( var type in self.connections ){
			connections = self.connections[type];
			for( var i = 0; i < connections.length; i++ ){
                if( connections[i].end == undefined ){ continue; }
                start = connections[i].start;
				end = connections[i].end ;
                if(start.y == end.y){
                    start_adjuster = (connections[i].start.type != 'p') ? .75 : 0 ;
                    end_adjuster = (connections[i].start.type != 'p') ? .75 : 0 ;
                    start_x_padding = padding;
                    end_x_padding = padding;
                    start_y_padding = padding;
                    end_y_padding = padding;
                    
                    start_x = (start.x > end.x) ?  start.x - start_x_padding - start_adjuster : start.x + start_x_padding + start_adjuster;
                    end_x = (start.x > end.x) ?  end.x + end_x_padding + end_adjuster : end.x - end_x_padding - end_adjuster;
                    start_y = start.y;
                    end_y = end.y;
                    
                }else if((start.y > end.y && start.y - end.y < 30) || (start.y < end.y && end.y - start.y < 30)){
                    start_adjuster = (connections[i].start.type != 'p') ? .75 : 0 ;
                    end_adjuster = (connections[i].start.type != 'p') ? .75 : 0 ;
                    start_x_padding = padding + 2.5;
                    end_x_padding = padding + .5;
                    start_y_padding = padding;
                    end_y_padding = padding;
                    
                    start_x = start.x - start_x_padding - start_adjuster;
                    end_x = end.x + end_x_padding + end_adjuster;
                    start_y = (start.y > end.y) ? start.y - 1 : start.y + 1;
                    end_y = (start.y > end.y) ? end.y + 1 : end.y - 1;
                    
                }else{
                    start_adjuster = (connections[i].start.type != 'p') ? .75 : 0 ;
                    end_adjuster = (connections[i].start.type != 'p') ? .75 : 0 ;
                    start_x_padding = padding;
                    end_x_padding = padding;
                    start_y_padding = padding;
                    end_y_padding = padding;
                    
                    start_x = start.x - start_x_padding - start_adjuster;
                    end_x = end.x + end_x_padding + end_adjuster;
                    start_y = (start.y > end.y) ? start.y - start_y_padding + start_adjuster: start.y + start_y_padding + start_adjuster;
                    end_y =  (start.y > end.y) ? end.y + end_y_padding + end_adjuster : end.y - end_y_padding + end_adjuster;
                    
                }
                
                wire_group = shapesKit.group(config.model.group);
                wire = new Kinetic.Line({
					points: [start_x, start_y, end_x, end_y],
					stroke: 'black',
					strokeWidth: 1.5
				});
                wire1 = new Kinetic.Line({
					points: [start_x, start_y, end_x, end_y],
					stroke: type_stroke[connections[i].end.type],
					strokeWidth: 1
				});
                wire2 = new Kinetic.Line({
					points: [start_x, start_y, end_x, end_y],
					stroke: type_stroke[connections[i].start.type],
					strokeWidth: 1,
					dash: [11, 11]
				});
				wire_group.add(wire);
				wire_group.add(wire1);
				wire_group.add(wire2);
				self.wiring_group.add(wire_group);
			}
		}
		self.wiring_layer.add(self.wiring_group);
	};
	self.setGridMode = function(mode){
		switch(mode){
			case 'add':
			case 'remove':
				self.grid_mode = mode;
				break;
			default:
				self.grid_mode = 'sequence';
				break;
		}
	};
	self.reorderFocusedGridArea = function(){
		if( self.focused_grid_area_id !== false){
            var model;
            var order = [];
            var reorder = [];
            var x;
            var sorter = [];
            var i; 
            var key;
            var grid_area = self.grid_areas[self.focused_grid_area_id];
            for( i=0; i<grid_area.models.length; i++ ){
                model = self.models[grid_area.models[i]];
                x = model.group.getAbsolutePosition().x;
                if( model.sequence_id == self.drag_id && self.grid_mode == 'remove'){ continue; }
                if( model.sequence_id == self.drag_id){ x++; }
                reorder[x] = i;
                sorter.push(x);
            }
            sorter.sort(function(a,b){return a - b});
            for(var i=0;i<sorter.length;i++){
                order.push(reorder[sorter[i]]);
            }
            grid_area.grid_order = order;
            self.grid_areas[self.focused_grid_area_id] = grid_area; 
		}
	};
	self.alignModelsToGrid = function(override_tweens){
        if( self.focused_grid_area_id !== false){
            var x;
            var y;
            var model;
            var grid_area = self.grid_areas[self.focused_grid_area_id];
            if(grid_area[self.grid_mode].length != 0){
                for(var i=0;i<grid_area[self.grid_mode].length;i++){
                    model = self.models[grid_area.models[grid_area.grid_order[i]]];
                    if(self.tweens_playing[i] == true && override_tweens != true){ continue; }
                    x = self.node.grid_areas[grid_area.id].x + grid_area[self.grid_mode][i];
                    y = self.node.grid_areas[grid_area.id].y - model.height;
                    if(self.dragging != false){
                        if(model.sequence_id != self.drag_id){
                            setTimeout(self.alignModelsTween,0, grid_area.models[grid_area.grid_order[i]], model, x, y);
                        }else{
                            if( grid_area.grid_order.length > 1){
                                grid_area.append_auger.group.show();
                                grid_area.prepend_auger.group.show();
                            }
                            if( i == 0 || i == grid_area.grid_order.length - 1){
                                grid_area.split_auger.group.hide();
                                self.grid_auger_split_position = false;
                            }else{
                                self.grid_auger_split_position = i;
                                grid_area.split_auger.group.setX(grid_area[self.grid_mode][i] + config.sequencer.grid_cell_width);
                                grid_area.split_auger.group.show();
                            }
                            self.grid_areas_layer.draw();
                        }
                    }else{
                        if(model.sequence_id != self.drag_id){
                            setTimeout(self.alignModelsTween,0, grid_area.models[grid_area.grid_order[i]], model, x, y);
                        }else{
                            setTimeout(self.alignModelsTween,0, self.drag_id, model, x, y);
                        }
                    }
                }
                self.sequence_layer.batchDraw();
            }
        }
	};
	self.alignModelsTween = function(id, model, x, y){
    	new Kinetic.Tween({
			node: model.group, 
			x: x,
			y: y,
			easing: Kinetic.Easings.EaseOut,
			duration: 0.2,
			onFinish: function() {
				self.tweens_playing[id] = false;
			}
		}).play();
		self.tweens_playing[id] = true;
	};
	self.saveSequence = function(model){
        if( self.focused_grid_area_id === false){
            if(self.node.s.length < 1 ){
                new XHRCall({route:'operations/sequode/addToSequence', inputs:[self.id, model.node.id, 0, 0, 0], done_callback: function(){registry.fetch({collection:'sequodes', key: self.id})}});
            }else if(self.focused_grid_area_id === false && model.original == true){
                new XHRCall({route:'operations/sequode/removeFromSequence', inputs:[self.id, model.sequence_order], done_callback: function(){registry.fetch({collection:'sequodes', key: self.id})}});
            }
            return;  
        }else if(self.focused_grid_area_id !== false){
            var sequence = [];
            var models_key;
            var position = 0;
            var gridarea_position = 0;
            var grid_area = 0;
            for(var i=0; i<self.grid_areas.length; i++){
                grid_area = self.grid_areas[i];
                for(var j=0; j<grid_area.grid_order.length; j++){
                    models_key = grid_area.models[grid_area.grid_order[j]];
                    if(model.original == true && self.models[models_key].sequence_order == model.sequence_order ){
                        new XHRCall({route:'operations/sequode/reorderSequence', inputs:[self.id, model.sequence_order, position, (j == 0) ? 0 : 1 ,(self.grid_area_augmenter == false) ? 0 : 1], done_callback: function(){registry.fetch({collection:'sequodes', key: self.id})}});
                        return;
                    }else if(model.original == false && self.models[models_key].original == false ){
                        new XHRCall({route:'operations/sequode/addToSequence', inputs:[self.id, model.node.id, position, (j == 0) ? 0 : 1 ,(self.grid_area_augmenter == false) ? 0 : 1], done_callback: function(){registry.fetch({collection:'sequodes', key: self.id})}});
                        return;
                    }
                    position++;
                }
            }
        }
    };
    self.saveGridArea = function(gridarea){
        var x,y,multiplier;
        var scale;
        if(gridarea.id == 0){return;}
        x = (self.node.grid_areas[gridarea.id].x - self.node.grid_areas[0].x);
        y = (self.node.grid_areas[gridarea.id].y - self.node.grid_areas[0].y);
        new XHRCall({route:'operations/sequode/moveGridArea', inputs:[self.id, gridarea.id, x, y], done_callback: function(){registry.fetch({collection:'sequodes', key: self.id})}});
	};
	self.detectCollision = function(a, b){
        var a_pos = a.getAbsolutePosition();
        var b_pos = b.getAbsolutePosition();
        return !(
        (a_pos.y + a.getHeight() < b_pos.y) ||
        (a_pos.y > b_pos.y + b.getHeight()) ||
        (a_pos.x + a.getWidth() < b_pos.x) ||
        (a_pos.x > b_pos.x + b.getWidth())
        );
    };
    self.setViewOffset = function(draw){
		for(i=0;i<self.view_layers.length;i++){
            self[self.view_layers[i]].setX(self.view_layers_offset.x);
            self[self.view_layers[i]].setY(self.view_layers_offset.y);
            if(draw != false){
                self[self.view_layers[i]].batchDraw();
            }
        }
	};
    self.gridAugerHitTest = function(grid_area, model){
        self.grid_area_augmenter = false;
        var auger;
        var stroke = 'black';
        var fill = 'darkgrey';
        var type;
        for(var i=0; i< self.grid_auger_types.length;i++){
            type = self.grid_auger_types[i];
            auger = type + '_auger';
            if(self.detectCollision(model.placement_collider,grid_area[auger].collider) && self.detectCollision(grid_area[auger].collider,model.placement_collider)){
                self.grid_area_augmenter = type;
                stroke = '#00FF00';
                fill = '#00FF00';
                break;
           }
        }
        if( grid_area[auger].circle.stroke() != stroke ){
            grid_area[auger].circle.setStroke(stroke);
            grid_area[auger].symbol.fill(fill);
            self.grid_areas_layer.draw();
        }
	};
    self.drawAllLayers = function(){
		for(i=0;i<self.all_layers.length;i++){
            self[self.all_layers[i]].batchDraw();
        }
	};
    self.drawViewLayers = function(){
		for(i=0;i<self.all_layers.length;i++){
            if(self[self.view_layers[i]]){
                self[self.view_layers[i]].batchDraw();
            }
        }
	};
    self.complete = function(){
        self.setViewOffset(false);
        self.first_run_complete = true;
        self.drawAllLayers();
    }
    self.gridAreaDropPosition = function(grid_area, not_group){
        var cell = {
            width:config.sequencer.grid_cell_width + (config.sequencer.grid_cell_width *.50),
            height:self.gridarea_height + (config.sequencer.grid_cell_width *.75)
        };
        var grid_x = (not_group == true) ? grid_area.x : grid_area.group.getX() + config.sequencer.grid_cell_width*.5 - 17.5;
        var grid_y = (not_group == true) ? grid_area.y : grid_area.group.getY() + self.gridarea_height;
        var x = (Math.floor(((not_group == true) ? grid_x : grid_x + (config.sequencer.grid_cell_width) - (config.sequencer.grid_cell_width *.50)) / cell.width)) * cell.width;
        var y = (Math.floor(((not_group == true) ? grid_y : grid_y - (config.sequencer.grid_cell_width*.5)) / cell.height)) * cell.height;
        return {x: (not_group == true) ? x : x - config.sequencer.grid_cell_width*.5 - 15 , y : (not_group == true) ? y : y - (self.gridarea_height) + (config.sequencer.grid_cell_width *.5)};
    };
    self.gridPlacementHitTest = function(grid_area){
        var grid_area_id;
        var stroke = '#00FF00';
        self.can_drop_grid_target = true;
        for(grid_area_id in self.grid_areas){
            if(grid_area_id == grid_area.id){continue};
            if(self.detectCollision(grid_area.placement_preview,self.grid_areas[grid_area_id].placement_collider) && self.detectCollision(self.grid_areas[grid_area_id].placement_collider,grid_area.placement_preview)){
                stroke = '#FF0000';
                self.can_drop_grid_target = false;
                break;
            }
        }
        if( grid_area.placement_preview.stroke() != stroke ){
           grid_area.placement_preview.setStroke(stroke);
           self.grid_areas_layer.draw();
        }
	};
    self.setConnectionReceiver = function(object){
        self.connection_receiver = object;
        self.addConnection();
	};
    self.setConnectionTransmitter = function(object){
        self.connection_transmitter = object;
        self.addConnection();
	};
    self.addConnection = function(){
        if(self.connection_receiver == false || self.connection_transmitter == false){
            return;
        }
        if(self.connection_receiver.type == 'external' && self.connection_transmitter.type == 'external'){
            self.connection_receiver = false;
            self.connection_transmitter = false;
            return;
        }
        var route = (self.connection_receiver.type == 'external' || self.connection_transmitter.type == 'external') ? 'operations/sequode/addExternalConnection' : 'operations/sequode/addInternalConnection';
        var type = (self.connection_receiver.type == 'external') ? self.connection_transmitter.type : self.connection_receiver.type;
        new XHRCall({route:route, inputs:[self.id,type,self.connection_transmitter.key,self.connection_receiver.key], done_callback: function(){registry.fetch({collection:'sequodes', key: self.id})}});
        self.connection_receiver = false;
        self.connection_transmitter = false;
	};
    self.cleanupAfterModelToGridAreaCollision = function(model, grid_area){
        if(self.focused_grid_area_id != model.grid_area){
            self.setGridMode('sequence');
            grid_area.models.pop();
        }else{
            self.setGridMode('remove');
        }
        var grid_order = [];
        for(var i=0; i < grid_area.grid_order.length;i++){
            if(i != grid_area.models.length){
                grid_order.push(i);
            }
        }
        grid_area.grid_order = grid_order;
        self.reorderFocusedGridArea();
        self.alignModelsToGrid(true);
        self.sequence_layer.draw();
        self.focused_grid_area_id = false;
        var box_width = grid_area.box.getWidth() - config.sequencer.grid_cell_width;
        grid_area.box.setWidth(box_width);
        grid_area.append_auger.group.setX(box_width);
        self.grid_areas[grid_area.id] = grid_area;
        if(grid_area.id+1 != self.grid_areas.length){
            self.grid_areas[grid_area.id+1].line.remove();
            self.grid_areas[grid_area.id+1].line.destroy();
            self.grid_areas[grid_area.id] = grid_area;
            self.makeGridFlowLine(grid_area.id+1,false);
        }
        self.grid_areas_layer.draw();
        grid_area.box.fill('white');
        self.grid_areas[grid_area.id] = grid_area;
        self.flow_lines_layer.show();
        
        self.grid_area_augmenter = false;
        for(var i=0; i< self.grid_auger_types.length;i++){
            type = self.grid_auger_types[i];
            auger = type + '_auger';
            grid_area[auger].circle.setStroke('black');
            grid_area[auger].symbol.fill('darkgrey');
        }
        self.grid_areas_layer.draw();
        self.grid_auger_split_position = false;
    };
    self.gridAreaWidth = function(models_count){
        return(models_count*config.sequencer.grid_cell_width) + (config.sequencer.grid_cell_width);
    };
    self.initialize();
    // Event Listeners attachments
	self.viewerPositionerEventListeners = function(positioner){
        if( self.default_events == true ){
            positioner.group = eventsKit.attachDraggableCursorEvents(positioner.group);
            positioner = self.attachViewDraggerEventOnDragStart(positioner);
            positioner = self.attachViewDraggerEventOnDragMove(positioner);
            positioner = self.attachViewDraggerEventOnDragEnd(positioner);
        }
        return positioner;
	};
	self.gridareaEventListeners = function(grid_area){
        if(grid_area.id == 0){
            grid_area.group.draggable(false);
        }else{
            if( self.default_events == true ){
                    grid_area.group = eventsKit.attachMoveableCursorEvents(grid_area.group);
                    grid_area = self.attachGridAreaEventOnDragStart(grid_area);
                    grid_area = self.attachGridAreaEventOnDragMove(grid_area);
                    grid_area = self.attachGridAreaEventOnDragEnd(grid_area);
            }
        }
		return grid_area;
	};
	self.modelEventListeners = function(model){
        
        if( self.default_events == true ){
            model = self.attachModelButtonsEventOnTap(model);
            model = self.attachModelEventOnDragStart(model);
            model = self.attachModelEventOnDragMove(model);
            model = self.attachModelEventOnDragEnd(model);
        }
		return model;
	};
	self.modelEndsEventListeners = function(model){
        
        if( self.default_events == true ){
            model = self.attachModelEndsEventButtonsOnTap(model);
            model = self.attachModelEndsEventBodyOnTap(model);
        }
		return model;
	};
    //drag event listner attachments
    self.attachGridAreaEventOnDragStart = function(gridarea){
		gridarea.group.on("dragstart", function(){
            
            self.flow_lines_layer.hide();
            self.ends_layer.hide();
            self.sequence_layer.hide();
            self.wiring_layer.hide();
            gridarea.placement_preview.show();
            gridarea.placement_preview.setPosition(self.gridAreaDropPosition(gridarea));
            self.drawViewLayers();
		});
		return gridarea;
	};
	self.attachGridAreaEventOnDragMove = function(gridarea){
        gridarea.group.on("dragmove", function(){
            gridarea.placement_preview.setPosition(self.gridAreaDropPosition(gridarea));
            gridarea.placement_collider.setPosition(self.gridAreaDropPosition(gridarea));
            self.grid_areas_layer.draw();
            setTimeout(self.gridPlacementHitTest,0,gridarea);
        });
		return gridarea;
	};
	self.attachGridAreaEventOnDragEnd = function(gridarea){
		gridarea.group.on("dragend", function(){
            gridarea.placement_preview.hide();
            self.grid_areas_layer.draw();
            if(self.can_drop_grid_target == true){
                self.node.grid_areas[gridarea.id].x = gridarea.group.getX() + config.sequencer.grid_cell_width*.5 + 15;
                self.node.grid_areas[gridarea.id].y = gridarea.group.getY() + gridarea.height - 15;
                self.saveGridArea(gridarea);
            }else{
                self.run();
            }
		});
		return gridarea;
	};
	self.attachViewDraggerEventOnDragStart = function(positioner){
        positioner.group.on("dragstart", function(){
            self.view_layers_starting_offset = {x:self.view_layers_offset.x,y:self.view_layers_offset.y};
        });
        return positioner;
    };
    self.attachViewDraggerEventOnDragMove = function(positioner){
        positioner.group.on("dragmove", function(){
            self.view_layers_offset = {x:positioner.group.getX() + self.view_layers_starting_offset.x,y:positioner.group.getY() +self.view_layers_starting_offset.y};
            self.setViewOffset(true);
        });
        return positioner;
    };
    self.attachViewDraggerEventOnDragEnd = function(positioner){
        positioner.group.on("dragend", function(){
            positioner.group.setX(0);
            positioner.group.setY(0);
            self.complete();
            self.view_layers_starting_offset = {x:0,y:0};
        });
        return positioner;
    };
    self.attachModelEventOnDragStart = function(model){
		model.group.on("dragstart", function(){
            var height = model.height * 1.667;
            var width = config.model.width * 1.667;
			self.ends_layer.hide();
			self.wiring_layer.hide();
            self.flow_lines_layer.hide();
			self.dragging = true;
			self.drag_id = model.sequence_order;
            self.focused_grid_area_id = model.grid_area;
		});
		return model;
	};
	self.attachModelEventOnDragMove = function(model){
        model.group.on("dragmove", function(){
            for(var grid_area_id in self.grid_areas){
                if(self.detectCollision(self.grid_areas[grid_area_id].placement_collider,model.placement_collider) && self.detectCollision(model.placement_collider,self.grid_areas[grid_area_id].placement_collider)){
                    if (self.focused_grid_area_id !== false && self.focused_grid_area_id != grid_area_id){
                        self.cleanupAfterModelToGridAreaCollision(model, self.grid_areas[self.focused_grid_area_id]);
                    }
                    var grid_area = self.grid_areas[grid_area_id];
                    if(self.focused_grid_area_id === false){
                        self.focused_grid_area_id = grid_area_id;
                        if(self.focused_grid_area_id != model.grid_area){
                            self.setGridMode('add');
                            grid_area.models.push(model.sequence_id);
                        }else{
                            self.setGridMode('sequence');
                        }
                        var box_width = grid_area.box.getWidth() + config.sequencer.grid_cell_width;
                        grid_area.box.setWidth(box_width);
                        grid_area.append_auger.group.setX(box_width);
                        self.grid_areas_layer.draw();
                        self.grid_areas[grid_area.id] = grid_area;
                        if(grid_area.id+1 != self.grid_areas.length){
                            self.grid_areas[grid_area.id+1].line.remove();
                            self.grid_areas[grid_area.id+1].line.destroy();
                            self.makeGridFlowLine(grid_area.id+1,false);
                        }
                        self.reorderFocusedGridArea();
                        self.alignModelsToGrid(true);
                        self.grid_areas_layer.draw();
                    }else{
                        self.reorderFocusedGridArea();
                        self.alignModelsToGrid(true);
                    }
                    if( grid_area.grid_order.length > 1){
                        self.gridAugerHitTest(grid_area,model);
                    }
                    break;
                }else{
                    if(self.focused_grid_area_id !== false){
                        self.cleanupAfterModelToGridAreaCollision(model, self.grid_areas[self.focused_grid_area_id]);
                    }
                }
            }
        });
        return model;
    };
	self.attachModelEventOnDragEnd = function(model){
		model.group.on("dragend", function(){
            self.modelOnDragEnd(model);
		});
		return model;
	};
    self.modelOnDragEnd = function(model){
		self.dragging = false;
        self.drag_id = false;
        if(self.grid_area_augmenter == false){
            self.alignModelsToGrid(true);
        }
        self.saveSequence(model);
	};
    //tap event listner attachments
    self.attachModelEndsEventButtonsOnTap = function(model){
		for(var type in model.buttons){
			for( var i in model.buttons[type] ){
				model.buttons[type][i] = self.attachModelEndsEventButtonOnTap(model.buttons[type][i],type,i);
			}
		}
		return model;
	};
	self.attachModelEndsEventButtonOnTap = function(shape,type,i){
		switch(type){
			case 'i':
				shape.on("click touchend", function(){
					clearTimeout(self.clickTimeout);
					self.clickTimeout = setTimeout(function(){
                        self.setConnectionTransmitter({'type':'input', 'key' : (i+1) });
					},300);
				});
				break;
			case 'p':
				shape.on("click touchend", function(){
					clearTimeout(self.clickTimeout);
					self.clickTimeout = setTimeout(function(){
                        self.setConnectionTransmitter({'type':'property', 'key' : (i+1) });
					},300);
				});
				break;
			default:
				break;
		}
		return shape;
	};
	self.attachModelEndsEventBodyOnTap = function(model){
		switch(model.type){
			case 'base':
				model.body.on("click touchend", function(){
					clearTimeout(self.clickTimeout);
                    self.setConnectionReceiver({'type':'external', 'key':0});
				});
				break;
			case 'head':
				model.body.on("click touchend", function(){
					clearTimeout(self.clickTimeout);   
                    self.setConnectionTransmitter({'type':'external', 'key':0});
				});
				break;
			default:
				break;
		}
		return model;
	};
	self.attachModelButtonsEventOnTap = function(model){
		for(var type in model.buttons){
			for( var i in model.buttons[type] ){
				model.buttons[type][i] = self.attachModelEventButtonOnTap(model.buttons[type][i],model.sequence_order,type,i);
			}
		}
		return model;
	};
	self.attachModelEventButtonOnTap = function(shape,i,type,j){
		switch(type){
			case 'i':
				shape.on("click touchend", function(){
					clearTimeout( self.clickTimeout );
                    self.setConnectionReceiver({'type':'input', 'key':(self.node.m[i][type][j].lead)});
				});
				break;
			case 'p':
				shape.on("click touchend", function(){
					clearTimeout(self.clickTimeout);
                    self.setConnectionReceiver({'type':'property', 'key':(self.node.m[i][type][j].lead)});
				});
				break;
			case 'o':
				shape.on("click touchend", function(){
					clearTimeout(self.clickTimeout);
                    self.setConnectionTransmitter({'type':'output', 'key':(self.node.m[i][type][j].lead)});
				});
				break;
			default:
				break;
		}
		return shape;
	};
    
}
var SequencerPalette = function(){
	var self = this;
    var sequencer;
    var stage;
    self.initialized = false;
    self.initialize = function(){
        if(self.initialized == true){ return;}
        self.initialized = true;
    };
	self.run = function (){
        self.tearDown();
        sequencer = self.parent;
        stage = self.parent.stage;
        self.grid_position = {x:32.5, y:stage.getHeight() - 8};
		self.temp_layer = new Kinetic.Layer();
		stage.add(self.temp_layer);
		self.background_layer = new Kinetic.Layer();
		stage.add(self.background_layer);
		self.models_layer = new Kinetic.Layer();
		stage.add(self.models_layer);
        self.models_layer.moveToTop();
		self.setupGrid();
        var grid_id = 0;
        self.models = [];
        var collection = registry.collection('palette');
        var i = 0 ;
		for( var id in collection ){
            setTimeout(self.makeModel, 0, id, i);
            i++;
		}
    };
    self.tearDown = function(){
		if(!self.models){ return; }
		self.models_layer.remove();
		self.background_layer.remove();
		self.temp_layer.remove();
		self.temp_layer.destroy();
		self.models_layer.destroy();
		self.background_layer.destroy();
        self.models = undefined;
        self.background_layer = undefined;
        self.models_layer = undefined;
        self.temp_layer = undefined;
        self.grid = undefined;
	};
	self.setupGrid = function(){
		self.grid = [];
        var collection_length = Object.keys(registry.collection('palette')).length;
        for(var i = 0; i < collection_length; i++) {
            self.grid[i] = (i*config.sequencer.grid_cell_width) + self.grid_position.x;
		}
	};
	self.makeModel = function(id,grid_id){
		var model = new Model();
		model.parent = self;
		model.original = false;
		model.grid_id = grid_id;
		model.node = registry.node('sequodes', id);
		model.id = id;
		model.stage = stage;
		model.layer = self.models_layer;
		model.x = self.grid[grid_id];
		model.y = 0;
		model.valignment = 'bottom';
		model.run();
	};
	self.modelComplete = function(model){
        self.models[model.grid_id] = self.modelEventListeners(model);
        if(self.models.length == Object.keys(registry.collection('palette')).length){
            self.modelsComplete();
        }
    };
    self.modelsComplete = function(model){
        setTimeout(self.makePaletteArea,0);
    };
    self.makePaletteArea = function(){
        var layer = {};
        layer.width = stage.getWidth()-12;
        layer.height = 8;
		layer.x = 6;
        layer.y = stage.getHeight() - 12.5;
        layer.box = new Kinetic.Rect({
            x: layer.x,
            y: layer.y,
            width: layer.width,
            height: layer.height,
            stroke: '#000000',
            strokeWidth: .5,
            cornerRadius: 2
		});
        
        self.background_layer.add(layer.box);
        self.background = layer;
        self.palette_state = 'open';
        self.models_layer.setY(self.grid_position.y);
        self.background_layer.draw();
        self.models_layer.batchDraw();
	};
    self.detectDragModelCollision = function(model){
        var grid_area_id;
        for(grid_area_id in sequencer.grid_areas){
            if(sequencer.detectCollision(sequencer.grid_areas[grid_area_id].box,model.body)){
                if (sequencer.focused_grid_area_id !== false && sequencer.focused_grid_area_id != grid_area_id){
                    self.cleanupAfterModelToGridAreaCollision(model, sequencer.grid_areas[sequencer.focused_grid_area_id]);
                }
                var grid_area = sequencer.grid_areas[grid_area_id];
                if(sequencer.focused_grid_area_id === false){
                    sequencer.focused_grid_area_id = grid_area_id;
                    sequencer.setGridMode('add');
                    var box_width = grid_area.box.getWidth() + config.sequencer.grid_cell_width;
                    grid_area.box.setWidth(box_width);
                    grid_area.append_auger.group.setX(box_width);       
                    sequencer.grid_areas_layer.batchDraw();
                    sequencer.sequence_layer.batchDraw();
                    model.original = false;
                    model.sequence_id = sequencer.sequence.length;
                    model.order = grid_area.models.length;
                    grid_area.models.push(model.sequence_id);
                    sequencer.models.push(model);
                    sequencer.drag_id = model.sequence_id;
                    sequencer.grid_areas[grid_area.id] = grid_area;
                    if(grid_area.id+1 != sequencer.grid_areas.length){
                        sequencer.grid_areas[grid_area.id+1].line.remove();
                        sequencer.makeGridFlowLine(grid_area.id+1,false);
                    }
                    sequencer.reorderFocusedGridArea();
                    sequencer.alignModelsToGrid(true);
                    sequencer.grid_areas_layer.draw();
                }else{
                    sequencer.reorderFocusedGridArea();
                    sequencer.alignModelsToGrid(true);
                }
                sequencer.gridAugerHitTest(grid_area,model);
                break;
            }else{
                if(sequencer.focused_grid_area_id !== false){
                    self.cleanupAfterModelToGridAreaCollision(model, sequencer.grid_areas[sequencer.focused_grid_area_id]);
                }
            }
        }
    };
    self.modelOnDragEndTween = function(tween_id, model, x, y){
        sequencer.alignModelsTween(tween_id, model, x, y);
    };
    self.cleanupAfterModelToGridAreaCollision = function(model, grid_area){
        sequencer.setGridMode('sequence');
        grid_area.models.pop();
        sequencer.models.pop();
        var grid_order = [];
        for(var i=0; i < grid_area.grid_order.length;i++){
            if(i != grid_area.models.length){
                grid_order.push(i);
            }
        }
        grid_area.grid_order = grid_order;
        sequencer.reorderFocusedGridArea();
        sequencer.alignModelsToGrid(true);
        sequencer.sequence_layer.draw();
        sequencer.focused_grid_area_id = false;
        var box_width = grid_area.box.getWidth() - config.sequencer.grid_cell_width;
        grid_area.box.setWidth(box_width);
        grid_area.append_auger.group.setX(box_width);
        sequencer.grid_areas[grid_area.id] = grid_area;
        if(grid_area.id+1 != sequencer.grid_areas.length){
            sequencer.grid_areas[grid_area.id+1].line.remove();
            sequencer.grid_areas[grid_area.id+1].line.destroy();
            sequencer.grid_areas[grid_area.id] = grid_area;
            sequencer.makeGridFlowLine(grid_area.id+1,false);
        }
        sequencer.grid_areas_layer.draw();
        grid_area.box.fill('white');
        sequencer.grid_areas[grid_area.id] = grid_area;
        sequencer.flow_lines_layer.show();
        sequencer.grid_area_augmenter = false;
        for(var i=0; i< sequencer.grid_auger_types.length;i++){
            type = sequencer.grid_auger_types[i];
            auger = type + '_auger';
            grid_area[auger].circle.setStroke('black');
            grid_area[auger].symbol.fill('darkgray');
        }
        sequencer.grid_areas_layer.draw();
        sequencer.grid_auger_split_position = false;
    };
	self.modelEventListeners = function(model){
        model.group = eventsKit.attachDraggableCursorEvents(model.group);
		model = self.attachEventModelOnDragStart(model);
		model = self.attachEventModelOnDragMove(model);
		model = self.attachEventModelOnDragEnd(model);
		return model;
	};
    self.attachEventModelOnDragStart = function(model){
		model.group.on("dragstart", function(event){
            model.group.remove();
			if(typeof(sequencer.sequence) != "object" || sequencer.sequence.length < 1 ){
                model.group.moveTo(self.temp_layer);
            } else {
                model.group.moveTo(sequencer.sequence_layer);
            }
            self.dragging = true;
            sequencer.dragging = true;
            model.original = false;
			if(typeof(sequencer.sequence) == "object" && sequencer.sequence.length > 0 ){
                sequencer.ends_layer.hide();
                sequencer.wiring_layer.hide();
                sequencer.flow_lines_layer.hide();
                sequencer.dragging = true;
                sequencer.focused_grid_area_id = false;
            }
		});
		return model;
	};
    self.attachEventModelOnDragMove = function(model){
		model.group.on("dragmove", function(){
            if(typeof(sequencer.sequence) != "object" || sequencer.sequence.length < 1 ){
                self.temp_layer.draw();
            }else{
                sequencer.sequence_layer.draw();
                self.detectDragModelCollision(model);
                setTimeout(sequencer.reorderFocusedGridArea,0);
            }
		});
		return model;
	};
    self.attachEventModelOnDragEnd = function(model){
		model.group.on("dragend", function(event){
            sequencer.dragging = false;
            if(typeof(sequencer.sequence) != "object" || sequencer.sequence.length < 1 ){
                self.temp_layer.draw();
            }else{
                sequencer.sequence_layer.draw();
            }
            sequencer.modelOnDragEnd(model);
		});
		return model;
	};
    self.initialize();
}
var SymbolsKit = function(){
	var self = this;
    self.symbols = {};
    self.symbols.flip_card = {
        text: $('<textarea />').html("&#8617;").text(),
		fontFamily:'Arial',
		x:0,
		y:0,
		fontSize:14,
		fontStyle:'bold',
		fill:'black'
    };
    self.symbols.search = {
        text: $('<textarea />').html("&#128269;").text(),
		fontFamily:'Segoe UI Symbol',
		x:7.5,
		y:-5.5,
		fontSize:18,
		fontStyle:'bold',
		fill:'#BCC6CC',
        shadowColor: 'black',
        shadowBlur: 2,
        shadowOffset: {x:0,y:0},
        shadowOpacity: 1.0
    };
    self.symbols.blank = {
        text: $('<textarea />').html("&#43;").text(),
		fontFamily:'Arial',
		x:11.5,
		y:-11.5,
		fontSize:28,
		fill:'#00FF00',
        shadowColor: 'black',
        shadowBlur: 2 ,
        shadowOffset: {x:0,y:0},
        shadowOpacity: 1.0
    };
    self.symbols.run = {
        text: $('<textarea />').html("&#9654;").text(),
		fontFamily:'Wingdings',
		x:12.5,
		y:-8.5,
		fontSize:22,
		fill:'#306EFF',
        shadowColor: 'black',
        shadowBlur: 2 ,
        shadowOffset: {x:0,y:0},
        shadowOpacity: 1.0
    };
    self.symbols.attributes = {
        text: $('<textarea />').html("&#123;..&#125;").text(),
		fontFamily:'Arial',
		x:12.5,
		y:-8.5,
		fontSize:16,
		fontStyle:'bold',
		fill:'yellow',
        shadowColor: 'black',
        shadowBlur: 2 ,
        shadowOffset: {x:0,y:0},
        shadowOpacity: 1.0
    };
    self.symbols.clone = {
        text: $('<textarea />').html("&#178;").text(),
		fontFamily:'Arial',
		x:14.5,
		y:-12.5,
		fontSize:32,
		fill:'#00FF00',
        shadowColor: 'black',
        shadowBlur: 2 ,
        shadowOffset: {x:0,y:0},
        shadowOpacity: 1.0
    };
    self.symbols.format = {
        text: $('<textarea />').html("&#8634;").text(),
		fontFamily:'Wingdings',
		x:10.5,
		y:-8.5,
		fontSize:20,
		fill:'red',
		fontStyle:'bold',
        shadowColor: 'black',
        shadowBlur: 2 ,
        shadowOffset: {x:0,y:0},
        shadowOpacity: 1.0
    };
    self.symbols.remove = {
        text: $('<textarea />').html("&#10007;").text(),
		fontFamily:'Wingdings',
		x:8.5,
		y:-8.5,
		fontSize:24,
		fill:'red',
        shadowColor: 'black',
        shadowBlur: 2 ,
        shadowOffset: {x:0,y:0},
        shadowOpacity: 1.0
    };
    self.symbols.component_settings = {
        text: $('<textarea />').html("&#9825;").text(),
		fontFamily:'sans-serif',
		fontSize:11,
		fill:'black'
    };
    self.copy = function(obj){
        var newObj = {};
        for(i in obj){
            newObj[i] = obj[i];
        }
        return newObj;
    }
    self.get = function(group,obj){
        var newObj = {};
        for(i in self[group][obj]){
            newObj[i] = self[group][obj][i];
        }
        return newObj;
    }
}
var ShapesKit = function(){
	var self = this;
	self.stage = function(o){
		return new Kinetic.Stage(o);
	};
	self.group = function(o){
		return new Kinetic.Group(o);
	};
	self.circle = function(o){
		return new Kinetic.Circle(o);
	};
	self.box = function(o){
		return new Kinetic.Rect(o);
	};
	self.label = function(o){
		return new Kinetic.Label(o);
	};
	self.tag = function(o){
		return new Kinetic.Tag(o);
	};
	self.text = function(o){
		return new Kinetic.Text(o);
	};
	self.tip = function(o){
        t = {};
        t.inpObj = config.get('tip','label');
        t.inpObj.x = o.x;
        t.inpObj.y = o.y;
        t.shape = self.label(t.inpObj);
        t.inpObj = config.get('tip','tag');
        t.shape.add(self.tag(t.inpObj));
        t.inpObj = config.get('tip','text');
        t.inpObj.text = o.text;
        t.shape.add(self.text(t.inpObj));
        return t;
	};
    self.textButton = function(x,y,text,font,fontsize){
        var shapes = {};
        var inpObj = {
            text: text,
            fill: 'black',
            x : x,
            y : y
        };
		shapes.group = new Kinetic.Group();
        shapes.text = self.text({
            text: text,
            fontFamily: font,
            fontSize: fontsize,
            fontWeight: 800,
            fill: 'black',
            x : x+5,
            y : y+5,
			shadowColor: 'black',
			shadowBlur: 1.5
        });
		shapes.button = new Kinetic.Rect({
            x: x,
            y: y,
            width: (shapes.text.getWidth() + 10),
            height: (shapes.text.getHeight() + 10),
            fill: 'white',
            stroke: 'black',
            cornerRadius: 5,
            strokeWidth: 1
		});
		shapes.group.add(shapes.button);
		shapes.group.add(shapes.text);
		return shapes;
	};
    self.boxShadow = function(x,y,width,height){
        var layer, shapes, modifier, orignial_modifier;
        orignial_modifier = 15;
        modifier = orignial_modifier;
        shapes = {};
        shapes.group = self.group({x:x,y:y});
        layer = {};
        layer.width = width + modifier;
        layer.height = height + modifier;
		layer.x = - (modifier * .5);
        layer.y = - (modifier * .5);
        layer.box = self.box({
            x: layer.x,
            y: layer.y, 
            fill: 'lightgray',
            opacity: .10,
            width: layer.width,
            height: layer.height,
            cornerRadius: 5
		});
        shapes.layer_1 = layer;
        shapes.group.add(layer.box);
        
        layer = {};
        modifier = orignial_modifier * .66;
        layer.width = width + modifier;
        layer.height = height + modifier;
		layer.x = - (modifier * .5);
        layer.y = - (modifier * .5);
        layer.box = self.box({
            x: layer.x,
            y: layer.y,
            fill: 'lightgray',
            opacity: .25,
            width: layer.width,
            height: layer.height,
            cornerRadius: 5
		});
        shapes.layer_2 = layer;
        shapes.group.add(layer.box);
        
        layer = {};
        modifier = orignial_modifier * .33;
        layer.width = width + modifier;
        layer.height = height + modifier;
		layer.x = - (modifier * .5);
        layer.y = - (modifier * .5);
        layer.box = self.box({
            x: layer.x,
            y: layer.y,
            fill: 'lightgrey',
            opacity: .50,
            width: layer.width,
            height: layer.height,
            cornerRadius: 5
		});
        shapes.layer_3 = layer;
        shapes.group.add(layer.box);
        return shapes;
	};
    
    self.circleShadow = function(x,y,radius){
        var layer, shapes, modifier, orignial_modifier;
        orignial_modifier = 9;
        modifier = orignial_modifier;
        shapes = {};
        shapes.group = self.group({x:x,y:y});
        layer = {};
        layer.radius = radius + modifier;
        layer.circle = self.circle({
            x: 0,
            y: 0, 
            fill: 'lightgray',
            opacity: .10,
            radius: layer.radius
		});
        shapes.layer_1 = layer;
        shapes.group.add(layer.circle);
        
        layer = {};
        modifier = orignial_modifier * .66;
        layer.radius = radius + modifier;
        layer.circle = self.circle({
            x: 0,
            y: 0, 
            fill: 'lightgray',
            opacity: .25,
            radius: layer.radius
		});
        shapes.layer_2 = layer;
        shapes.group.add(layer.circle);
        
        layer = {};
        modifier = orignial_modifier * .33;
        layer.radius = radius + modifier;
        layer.circle = self.circle({
            x: 0,
            y: 0, 
            fill: 'lightgrey',
            opacity: .50,
            radius: layer.radius
		});
        shapes.layer_3 = layer;
        shapes.group.add(layer.circle);
        return shapes;
	};
    self.circleButton = function(text){
		var inpObj, link;
		var radius = 9;
        if(text.text){
            inpObj = text;
        }else{
            inpObj = config.get('model_detail','help');
            inpObj.text = text;
        }
        layer = {};
        layer.group = self.group({});
        layer.text = self.text(inpObj);
		layer.x = (layer.text.getTextWidth()/2)-.5;
        layer.y = Math.floor(layer.text.getTextHeight()/2);
        layer.radius = radius;
                
		layer.circle = self.circle({
            x: layer.x,
            y: layer.y,
            radius: layer.radius,
            stroke: 'darkgray',
            strokeWidth: 1,
            fillRadialGradientEndRadius: layer.radius,
            fillRadialGradientColorStops:[0, 'white', 0.75, 'white', 0.80, 'lightgray',  0.90, 'darkgray', 1, 'white']
		});
        
        
        layer.group.add(layer.circle);
        layer.group.add(layer.text);
        
        layer.hit_area = layer.circle;
        
        return layer;
    }
}

var SequodeConsoleRegistry = function(){
	var self = this;
	self.origin_host = 'https://origin.sequode.com';
	self.collections_feed = '/collections';
    self.collections = {};
    self.active_context = false;
    self.context_log = [];
    self.setContext = function(context){
        var o = {card:'',collection:'',node:'',tearDown:function(){return;}};
        for(var i in o){
            if(i in context){
                o[i] = context[i];
            }
        }
        self.context_log.push(o);
        if(self.active_context != false){
            self.active_context.tearDown;
        }
        self.clearTypeSubscriptions('context');
        self.active_context = o;
        self.active_collection = o.collection;
    };
    self.active_collection = '';
    self.update_subscriptions = [];
    self.timeouts = [];
    
    self.fetch = function(o){
        var call = function(o){
            var route = self.collections_feed;
            for(var i in o){
                route = route + '/' + o[i];
            }
            var fetched = {};
            $.ajax({
                type: "POST",
                url:  self.cacheBust(route),
                dataType: "json",
                success: function(data){
                    o.data = data;
                    self.fetched(o);
                }
            });
        };
		setTimeout(call, 0, o);
    }
    self.fetched = function(o){
        var notify = {};
        if('collection' in o){
            notify['collection'] = o.collection;
            if('key' in o){
                self.collections[o.collection][o.key] = o.data;
                notify.key = o.key;
            }else{
                self.collections[o.collection] = o.data;
            }
        }else{
            notify['collection'] = 'collections';
            self.collections = o.data;
        }
        self.notifySubscriber(notify);
    }
    self.nextNode = function(collection, id){
        var keys = Object.keys( collection );
        var key = keys.indexOf( id );
        if((key + 1) < keys.length){
            return keys[ (key + 1) ];
        }else{
            return keys[0];
        }
        
    };

    self.previousNode = function(collection, id){
        var keys = Object.keys( collection );
        var key = keys.indexOf( id );
        var next_id = key -= 1;
        if(next_id === keys.length){
            next_id = keys.length - 1;
        }
        return keys[next_id];
    };
    self.node = function(collection, id){
        return self.collections[collection][id];
    }
    self.collection = function(collection){
        return self.collections[collection];
    }
    self.subscribeToUpdates = function(o){
        self.update_subscriptions.push(o);
    }
    self.clearTypeSubscriptions = function(type){
        var o;
        var update_subscriptions = [];
        for(var i in self.update_subscriptions){
            o = self.update_subscriptions[i];
            if(o.type != type){
                update_subscriptions.push(o);
            }
        }
        self.update_subscriptions = update_subscriptions;
    }
    self.notifySubscriber = function(o){
        var subscription;
        if(o.collection != 'collections'){
            if('key' in o){
                for(var i in self.update_subscriptions){
                    subscription = self.update_subscriptions[i];
                    if(subscription.collection != o.collection){
                        continue;
                    }
                    if('key' in subscription){
                        setTimeout(subscription.call, 0, o.key);
                    }else{
                        setTimeout(subscription.call, 0);
                    }
                }
            }else{
                for(var i in self.update_subscriptions){
                    subscription = self.update_subscriptions[i];
                    if(subscription.collection != o.collection){
                        continue;
                    }
                    setTimeout(subscription.call, 0);
                }
            }
        }else{
            main.startUp();
        }
    }
    
    
    self.timeout = function(key, timeout, delay){
        if (!self.timeouts[key] != null){
            window.clearTimeout(self.timeouts[key]);
        }
        self.timeouts[key] = window.setTimeout( timeout, delay );
    }
	self.getURLVar = function(name){
		var urlVaribles = String(document.location).split('?')[1].split('&');
		for(i=0; i<=(urlVaribles.length); i++){
			if (urlVaribles[i].split('=')[0] && urlVaribles[i].split('=')[0] == name){
				return urlVaribles[i].split('=')[1];
			}
		}
	};
    self.cacheBust = function(url){
        return url + (url.indexOf('?') > -1 ? '&' : '?') + 'cb=' +  Math.round(new Date().getTime() / 1000);
    };
}
var SequodeConsole = function(){
	var self = this;
	self.tearDown = function(){
        main, baseKit, registry, config, shapesKit, cardsKit, eventsKit = undefined;
        document.getElementsByTagName('body')[0].innerHTML = '';
	};
	self.startUp = function(){
		self.placeContainers();
        setTimeout(self.setContext,0);
	};
    if(typeof main === 'object'){
        main.tearDown();
    }
    main = self;
    config = new Configuration();
	baseKit = new BaseKit();
	shapesKit = new ShapesKit();
	cardsKit = new Cards();
	eventsKit = new EventsKit();
	registry = new SequodeConsoleRegistry();
	self.loadMenus = function() {
        new XHRCall({route:'cards/console/menus', inputs:['MenusContainer']});
    };
    self.loadCard = function(route, inputs) {
        new XHRCall({route:route, inputs:inputs});
    };
	self.setContext = function(){
        var call = {route:baseKit.getURLVar("card"),inputs:[]};
        if(call.route === null){
            call.route = 'console/index';
        }else if(baseKit.getURLVar("id") !== null){
            call.inputs.push(baseKit.getURLVar("id"));
        }
        call.route = 'cards/' + call.route;
        new XHRCall(call);
	};
    self.placeContainers = function(){
        var html = 
           ['<div id="MenusContainer" class="fitBlock alignLeft"></div>',
            '<div id="BodyContainer" class="fitBlock alignLeft">',
            '<div id="bodyCardGridCardsContainer" class="body-card-grid">',
            '<div class="full-grid-cell alignCenter">',
            '<div id="CardsContainer" class="auto-grid-cell"></div>',
            '</div>',
            '</div>'
           ].join('');
        document.getElementsByTagName('body')[0].innerHTML = html;
        setTimeout(self.loadMenus,0);
	};
    registry.fetch({});
}
    var main, baseKit, registry, config, shapesKit, cardsKit, eventsKit, collection_cards;
    new SequodeConsole();